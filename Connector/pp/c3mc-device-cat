#!/data/Software/mydan/perl/bin/perl
use strict;
use warnings;
use YAML::XS;

binmode STDIN,  ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';


=head1 SYNOPSIS

 $0 time|curr type subtype
 $0 time|curr type subtype grepuuid

=cut

my ( $curr, $type, $subtype, $grepuuid ) = @ARGV;
die "argv err" unless $subtype;

$curr = "timemachine/$curr" if $curr ne 'curr';

my $path = "/data/open-c3-data/device/$curr/$type/$subtype";
my $file = "$path/data.tsv";

die "nofile $file" unless -f $file;
my @data = `cat $file`;
exit unless @data;
chomp @data;

my $util = eval{ YAML::XS::LoadFile "$path/util.yml" };
die "load util fail: $@" if $@;
my $defaulttree = $util->{defaulttree};
my $copytreecol = $util->{copytreecol};
$copytreecol ||= '_tree_';
$copytreecol = [ $copytreecol ] if ref $copytreecol ne 'ARRAY';

my %treeow;
my $_tree_ = grep{ $_ eq '_tree_' }@$copytreecol;
if( $_tree_ )
{
    if( $curr eq 'curr' )
    {
        my @treeow = `c3mc-base-db-get -t openc3_device_bindtree uuid tree -f 'type="$type" and subtype="$subtype"'`;
        chomp @treeow;

        for( grep{ /^[a-zA-Z0-9]/ }@treeow )
        {
            my ( $uuid, $tree ) = split /;/, $_, 2;
            $treeow{ $uuid } = $tree;
        }
    }
    else
    {
        my @treeow = `cat /data/open-c3-data/device/$curr/openc3_device_bindtree.txt`;
        chomp @treeow;
        for( grep{ /^[a-zA-Z0-9]/ }@treeow )
        {
            my ( $typet, $subtypet, $uuid, $tree ) = split /;/, $_, 4;
            next unless $typet && $subtypet && $typet eq $type && $subtypet eq $subtype;
            $treeow{ $uuid } = $tree;
        }
    }
}

my $colname = eval{ YAML::XS::LoadFile "$path/colmap.yml" };
die "load colmap fail: $@" if $@;

die "treename undef in colmap.yml" unless my $treenamecol = $colname->{ treename };
die "uuid     unfef in colmap.yml" unless my $uuidcol     = $colname->{ uuid     };

my $title = shift @data;
utf8::decode($title);
my @title = split /\t/, $title;

my @ptitle = @title;
push @ptitle, $treenamecol unless grep{ $_ eq $treenamecol }@title;
push @ptitle, '_tree_' if $_tree_;

printf "\%s\n", join "\t", @ptitle;
for my $data ( @data )
{
    utf8::decode($data);
    my @d = split /\t/, $data;

    my %d = map{ $title[ $_ ] => $d[ $_ ] } 0 .. @title - 1;

    $d{ _tree_       } = $treeow { $d{ $uuidcol } } if $_tree_;
    $d{ $treenamecol } = join ',', grep{ $_ }map{ $d{ $_ } }@$copytreecol;

    if( $defaulttree && ! $d{ $treenamecol } )
    {
        $d{ $treenamecol } = $defaulttree;
    }
    next if $grepuuid && $d{ $uuidcol} ne $grepuuid;

    printf "%s\n", join "\t", map{ $d{$_} // '' }@ptitle;
}
