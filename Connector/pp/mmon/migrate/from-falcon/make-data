#!/opt/mydan/perl/bin/perl
use strict;
use warnings;
use FindBin qw( $RealBin );
use Data::Dumper;
use LWP::UserAgent;
use YAML::XS;
use Digest::MD5;

my @x = <STDIN>;
chomp @x;

my $title = shift @x;
my @title = split /\t/, $title;

my %mark = map{ $_ => 1 }@ARGV;

my %count;
my $dist = "$RealBin/dist";

sub makedata_collector_filecheck
{
    my $data = shift @_;
    my $tpl_file = "$RealBin/tpl/collector/$data->{metric}";

    my $tpl = `cat '$tpl_file'`;

    my %var;
    if( $data->{tags} =~ m#path=([\/a-zA-Z0-9\-\.]+),type=([a-z]+)# )
    {
        %var = ( path => $1, type => $2 );
    }
    else
    {
        warn "err";
        return;
    }

    for my $k ( qw( path type ) )
    {
        my $v = $var{$k};
        $tpl =~ s/\$VAR\{$k\}/$v/g;
    }

    my $path = "$dist/collector/$data->{treeid}";
    system "mkdir -p '$path'" unless -d $path;
    my $file = "$path/$data->{tpl_name}";
    print "make collector: $data->{metric} $file\n";
    my $H;
    open($H, ">$file" ) || die "open $file $!";
    print $H $tpl;
    close $H;
}

sub makedata_collector_procnum
{
    my $data = shift @_;
    my $tpl_file = "$RealBin/tpl/collector/$data->{metric}";

    my $tpl = `cat '$tpl_file'`;

    my ( $type, $name );
    if( $data->{tags} =~ m#name=([a-zA-Z0-9\-\.]+)# )
    {
        ( $type, $name ) = ( 'name', $1 );
    }
    elsif( $data->{tags} =~ m#cmdline=([a-zA-Z0-9\-\.]+)# )
    {
        ( $type, $name ) = ( 'cmdline', $1 );
    }
 
    else
    {
        warn "err";
        return;
    }

    my %var = ( type => $type, name => $name );

    for my $k ( qw( type name ) )
    {
        my $v = $var{$k};
        $tpl =~ s/\$VAR\{$k\}/$v/g;
    }

    my $path = "$dist/collector/$data->{treeid}";
    system "mkdir -p '$path'" unless -d $path;
    my $file = "$path/$data->{tpl_name}";
    print "make collector: $data->{metric} $file\n";

    my $H;
    open($H, ">$file" ) || die "open $file $!";
    print $H $tpl;
    close $H;
}

sub makedata_rule
{
    my $data = shift @_;
    my $tpl_file = "$RealBin/tpl/rule/$data->{metric}";

    if( $data->{metric} eq 'sys.disk.rw' )
    {
        print "skip $data->{metric}\n";
        return;
    }

    unless( -f $tpl_file )
    {
        warn "[ERROR] nofind rule tpl: $data->{metric}\n";
        return;
    }
    my $tpl = `cat '$tpl_file'`;

    for my $k ( qw( priority for right_value ) )
    {
        my $v = $data->{$k};
        $tpl =~ s/\$VAR\{$k\}/$v/g;
    }

    my $path = "$dist/rule/$data->{treeid}";
    system "mkdir -p '$path'" unless -d $path;

    my $md5 = Digest::MD5->new->add( $tpl )->hexdigest;

    my $file = "$path/$data->{tpl_name}.$md5";
    print "make: $data->{metric} $file\n";

    my $H;
    open($H, ">$file" ) || die "open $file $!";
    print $H $tpl;
    close $H;
}

for ( @x )
{
    my @t = split /\t/, $_;

    my $d = +{ map{ $title[$_] => $t[$_] }0..@title -1};
    $d->{for} = '';

    if( $d->{func} && $d->{func} =~ /^[a-z]+\(#(\d+)\)$/ )
    {
        $d->{for} = "$1m";
    }

    if( index( $d->{metric}, 'proc.num/name=' ) == 0 && $d->{tags} eq 'NULL' )
    {
        $d->{metric} =~ /^proc.num\/(name=.+)$/;
        $d->{tags} = $1;
        $d->{metric} =  'proc.num';
    }

    makedata_rule( $d );
    makedata_collector_filecheck( $d ) if $d->{metric} eq 'file.check';
    makedata_collector_procnum(   $d ) if $d->{metric} eq 'proc.num';
}
