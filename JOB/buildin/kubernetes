#!/data/Software/mydan/perl/bin/perl -I/data/Software/mydan/JOB/lib
use strict;
use warnings;
use MYDan::Util::OptConf;
use LWP::UserAgent;
use JSON;
use FindBin qw( $RealBin );
use MYDB;
use Util;
use uuid;
use kubernetes;

=head1 SYNOPSIS

 $0 deploy
 $0 check

=cut

my $option = MYDan::Util::OptConf->load();
$option->assert() unless @ARGV;

die "nonode" unless $ENV{NODE};

sub success
{
    map{ print "$_:ok\n"; } split /,/, $ENV{NODE};
    exit;
}

my ( $treeid, $flowid, $version ) = @ENV{qw( TREEID FLOWID VERSION )};

my %callenv = Util::envinfo( qw( appname appkey ) );
my $ua = LWP::UserAgent->new;
$ua->default_header( %callenv );

my $res = $ua->get( "http://api.ci.open-c3.org/project/$treeid/$flowid" );

die "get ci config fail:" . $res->content unless $res->is_success;

my $data = eval{ JSON::from_json $res->content };
die "get ci config fail: $@" if $@;
die "get ci config fail:" . $res->content unless $data && $data->{stat};

my %data = %{$data->{data}};

die "ci_type no kubernetes" unless $data{ci_type} && $data{ci_type} eq 'kubernetes';
die "ci_type_ticketid format error" unless $data{ci_type_ticketid} && $data{ci_type_ticketid} =~ /^\d+$/;
die "ci_type_kind format error" unless $data{ci_type_kind} && $data{ci_type_kind} =~ /^[a-zA-Z0-9]+$/;
die "ci_type_namespace format error" unless $data{ci_type_namespace} && $data{ci_type_namespace} =~ /^[a-zA-Z0-9]+$/;
die "ci_type_name format error" unless $data{ci_type_name} && $data{ci_type_name} =~ /^[a-zA-Z][a-zA-Z0-9_\-]+$/;
die "ci_type_container format error" unless $data{ci_type_container} && $data{ci_type_container} =~ /^[a-zA-Z][a-zA-Z0-9_\-]+$/;
die "ci_type_dockerfile format error" unless $data{ci_type_dockerfile} && $data{ci_type_dockerfile} =~ /^[a-zA-Z0-9]+$/;
die "ci_type_repository format error" unless $data{ci_type_repository} && $data{ci_type_repository} =~ /^[a-zA-Z][a-zA-Z0-9_\-\/\.]+$/;


my $db = MYDB->new( "$RealBin/../../CI/conf/conn" );
my $kubectl = eval{ kubernetes::getKubectlCmd( $db, $data{ci_type_ticketid}, 'user', 'company',  0 ) };
die "get kubectl fail: $@" if $@;
undef $db;

if( $ARGV[0] && $ARGV[0] eq 'deploy' )
{
    die "update fail: $!" if system "$kubectl set image '$data{ci_type_kind}' '$data{ci_type_name}' '$data{ci_type_container}=$data{ci_type_repository}:$version' -n '$data{ci_type_namespace}'";

}
elsif( $ARGV[0] && $ARGV[0] eq 'check' )
{
    my $timeout = $ENV{TIMEOUT} && $ENV{TIMEOUT} =~ /^\d+$/ ? time + $ENV{TIMEOUT} : time  +  60; 

    my $check = sub{
        my $stat = `$kubectl get '$data{ci_type_kind}' '$data{ci_type_name}' -n '$data{ci_type_namespace}' -o yaml`;
        my $conf = eval{ YAML::XS::Load $stat };
        my ( $containers, $status ) = ( $conf->{spec}{template}{spec}{containers}, $conf->{status} );
        my ( $container ) = grep{ $_->{name} eq $data{ci_type_container} }@$containers;
        unless( $container )
        {
            warn "no container name: $data{ci_type_container}\n";
            return;
        }
        if( $container->{"image"} eq "$data{ci_type_repository}:$version" )
        {
            warn "image ok: $container->{image}\n";
        }
        else
        {
            warn "current: $container->{image} desired: $data{ci_type_repository}:$version\n";
            return;
        }

        if( $status->{unavailableReplicas} )
        {
            warn "status unavailableReplicas: $status->{unavailableReplicas}\n";
            return;
        }
        else { return 1; }
    };

    for( 1 .. 360 )
    {
        last if &$check();
        sleep 10;
        die "check timeout.\n" if time > $timeout;
    }
}
else { die "argv unkown"; }

success();
